# Path: merge_files.py
from glob import glob
import os

files = glob('**/*.py', recursive=True)

merged_files = ""

for file in files:
    with open(file, 'r') as f:
        content = f.read() + "\n\n"
    
    merged_files += "# Path: " + os.path.basename(file) + "\n"
    merged_files += content

with open('merged_files.txt', 'w') as f:
    f.write(merged_files)

# Path: runner.py
from heat_transfer.models.room import *
from heat_transfer.models.house import *
from heat_transfer.generic import *
from heat_transfer.model_parameters import Config
from matplotlib import pyplot as plt
import numpy as np
from vpython import *


class Plot:
    def __init__(self, rooms: list[Room]):
        self.fig, self.ax = plt.subplots()

        self.rooms = rooms
        self.x_data = []
        self.y_data = {room.id: [] for room in rooms}
        self.lines = {room.id: self.ax.plot(self.x_data, self.y_data[room.id], '-')[0] for room in rooms}

        # Set plot limits
        self.ax.set_xlim(0, 100)
        self.ax.set_ylim(0, 50)
        self.ax.set_xlabel("Time [h]")
        self.ax.set_ylabel("Temperature [°C]")
        # set legend
        self.ax.legend([f"Room {room.id}" for room in rooms])
    
    def update(self, hours_passed: int):
        self.x_data.append(hours_passed)
        for room in self.rooms:
            self.y_data[room.id].append(room.temperature - 273.15)

            # Update plot
            self.lines[room.id].set_xdata(self.x_data)
            self.lines[room.id].set_ydata(self.y_data[room.id])

        self.ax.relim()
        self.ax.autoscale_view()

        # Refresh the plot
        plt.draw()
        plt.pause(0.5)



# x - szerokość, y -wysokość, z - długość
room1 = Room(1,
             (3, 4, 3), 
             13,
             vector(4.5, 0, 0),
             parent=None)

room2 = Room(2,
            (6, 4, 3),
            25,
            vector(0, 0, 0),
            parent=None)

room3 = Room(3,
            (6, 4, 3),
            40,
            vector(0, 0, 3),
            parent=None)


house = House([room1, room2, room3],
              interfaces=[[[room2, room1], Direction(Axis.X, True)], [[room2, room3], Direction(Axis.Z, True)]],
              wall_layers=[(0.1, Material(2500, 800, 1.4))],
              roof_layers=[(0.1, Material(2500, 800, 1.4))],
              floor_layers=[(0.1, Material(2500, 800, 1.4))],
              local_position=vector(0, 0, 0))


room1.make_box(temperature=room1.temperature)
room2.make_box(temperature=room2.temperature)
room3.make_box(temperature=room3.temperature)



room1.add_windows(Direction(Axis.Z, False), 1)
room1.add_windows(Direction(Axis.Z, True), 1)
room1.add_windows(Direction(Axis.X, True), 1)
room1.add_door(Direction(Axis.X, False))

room2.add_door(Direction(Axis.Z, True))
room2.add_windows(Direction(Axis.Z, False), 2)
room2.add_windows(Direction(Axis.X, False), 1)

room3.add_windows(Direction(Axis.Z, True), 2)
room3.add_windows(Direction(Axis.X, True), 1)
room3.add_windows(Direction(Axis.X, False), 1)

room1.visualize_openings()
room2.visualize_openings()
room3.visualize_openings()


plot = Plot(rooms=[room1, room2, room3])

house.print_rooms_temperatures()

room_temperature_logs = {room.id: [room.temperature] for room in house.rooms}
UPDATE_STEP = 3 # in hours

for i in range(50):
    for __ in range(UPDATE_STEP * 3600 // Config().TIME_STEP):
        house.update_temperature()

    house.update_visuals()
    house.print_rooms_temperatures()
    plot.update(UPDATE_STEP*(i+1))
    print(UPDATE_STEP*(i+1), "hours passed")

plt.show()
input()

# Path: generic.py
from math import prod
from enum import Enum, IntEnum
from dataclasses import dataclass

from vpython import vector
from .visualization import *

class Axis(IntEnum):
    X = 0
    Y = 1
    Z = 2


@dataclass(frozen=True)
class Direction:
    axis: Axis
    positive: bool

    
class HeatingSystem:
    def __init__(self, name, power, temperature):
        self.name = name
        self.power = power
        self.temperature = temperature


class Material:
    density: float # kg/m^3
    specific_heat_capacity: float # J/(kg*K)
    conductivity: float # W/(m*K)

    def __init__(self, density: float, specific_heat_capacity: float, conductivity: float):
        self.density = density
        self.specific_heat_capacity = specific_heat_capacity
        self.conductivity = conductivity


class UniformTemperatureObject:
    temperature: float # K
    material: Material
    volume: float | None = None # m^3
    object_type: str | None

    def __init__(self, temperature_celsius: float, material: Material, volume: float | None = None, object_type: str | None = None):
        self.temperature = temperature_celsius + 273.15
        self.material = material
        self.volume = volume
        self.object_type = object_type

    @property
    def mass(self) -> float:
        return self.volume * self.material.density

    def update_temperature(self, heat: int):
        if self.volume is not None:
            self.temperature += heat / (self.material.specific_heat_capacity * self.mass)

        # else:  infinite heat capacity -> temperature does not change

    def __str__(self):
        return f"{self.object_type} at {self.temperature} K"

    def __repr__(self):
        return f"{self.object_type} at {self.temperature} K"


# Path: heat_flow.py
from .generic import *
from .model_parameters import Config
from .models.room import *
from .models.layered_objects import MultiLayerObject
import numpy as np


class HeatFlow:
    @staticmethod
    def update_temperature(interfaces: list[MultiLayerObject]):
        object_heat: dict[UniformTemperatureObject, float] = dict()
        for interface in interfaces:
            for object, heat in HeatFlow.update_temperature_at_interface(interface).items():
                if object in object_heat:
                    object_heat[object] += heat
                else:
                    object_heat[object] = heat

        for object, heat in object_heat.items():
            object.update_temperature(heat)
            if object.temperature < 0:
                print("temperature < 0")
                print("interface:", interfaces)
                print("object:", object)
                print("heat:", heat)
                print("object_heat:", object_heat)
                exit()

    @staticmethod
    def update_temperature_at_interface(interface: MultiLayerObject):
        prev_node = None
        object_heat: dict[UniformTemperatureObject, float] = dict()
        object_heat.update({node: 0 for node in interface.nodes}) # net heat for wall nodes
        object_heat.update({border: 0 for border in interface.border}) # net heat for bordering objects

        # conduction through the interface
        for layer in interface.layers:
            for node in layer.nodes:
                if prev_node is None:
                    prev_node = node
                    continue

                heat_flux = Conduction.heat_flux(prev_node, node, Config().NODE_DISTANCE, layer.material)
                heat = heat_flux * Config().TIME_STEP * interface.area

                object_heat[node] -= heat
                object_heat[prev_node] += heat

                prev_node = node


        border1_object = interface.border[0]
        border1_outer_node = interface.layers[0].nodes[0]
        border2_object = interface.border[-1]
        border2_outer_node = interface.layers[-1].nodes[-1]

        border1_isair = isinstance(border1_object, Room) or (border1_object == Config().ENVIRONMENT)
        border2_isair = isinstance(border2_object, Room) or (border2_object == Config().ENVIRONMENT)


        if border1_isair:
            bordering_air = border1_object
            bordering_node = border1_outer_node
            heat_flux = Convection.heat_flux(bordering_node, bordering_air, interface.axis1_length)
            heat = heat_flux * Config().TIME_STEP * interface.area

            object_heat[bordering_node] -= heat
            object_heat[bordering_air] += heat
        else:
            heat_flux = Conduction.heat_flux(border1_outer_node, border1_object, Config().NODE_DISTANCE)
            heat = heat_flux * Config().TIME_STEP * interface.area

            object_heat[border1_object] -= heat
            object_heat[border1_outer_node] += heat


        if border2_isair:
            bordering_air = border2_object
            bordering_node = border2_outer_node
            heat_flux = Convection.heat_flux(bordering_node, bordering_air, interface.axis1_length)
            heat = heat_flux * Config().TIME_STEP * interface.area

            object_heat[bordering_node] -= heat
            object_heat[bordering_air] += heat
        else:
            heat_flux = Conduction.heat_flux(border2_outer_node, border2_object, Config().NODE_DISTANCE)
            heat = heat_flux * Config().TIME_STEP * interface.area

            object_heat[border2_object] -= heat
            object_heat[border2_outer_node] += heat
        
        return object_heat


class Conduction:
    @staticmethod
    def heat_flux(node1: UniformTemperatureObject, node2: UniformTemperatureObject, distance: float, material: Material | None = None):
        if material is None:
            conductivity = (node1.material.conductivity + node2.material.conductivity) / 2
        else:
            conductivity = material.conductivity

        heat_flux = conductivity * (node2.temperature - node1.temperature) / distance


        return heat_flux


class Convection:
    @staticmethod
    def heat_flux(bordering_node: UniformTemperatureObject, bordering_air: UniformTemperatureObject, characteristic_length: float):
        # assumptions for grashof number calculation:
        # k = 0.026 W/(m*K)
        # kinematic viscosity = 1.5 * 10^-5 m^2/s
        # g = 9.81 m/s^2
        # specific heat = 1005 J/(kg*K)
        # thermal expansion coefficient is the inverse of the temperature in K
        # characteristic length = height of the wall

        prandtl_number = 0.71
        grashof_number = 88979591837 * characteristic_length**3 * abs(bordering_node.temperature - bordering_air.temperature) / bordering_air.temperature 
        
        rayleigh_number = grashof_number * prandtl_number

        # assumptions for nusselt number calculation:
        # 10^4 < Ra < 10^9
        # => constants C=0.59 and n=0.25

        nusselt_number = 0.59 * rayleigh_number**0.25

        heat_transfer_coefficient = nusselt_number * Config().AIR.conductivity / characteristic_length

        heat_flux = heat_transfer_coefficient * (bordering_node.temperature - bordering_air.temperature)

        return heat_flux

# Path: model_parameters.py
from .generic import UniformTemperatureObject, Material


TIME_STEP = 1 # s
NODE_DISTANCE = 0.03 # m
AIR = Material(1225, 1005, 0.024)
GLASS = Material(2500, 840, 1)
WOOD = Material(300, 1800, 0.1)
ENVIRONMENT = UniformTemperatureObject(15, Material(1225, 1005, 0.024), object_type="environment")
GROUND = UniformTemperatureObject(15, Material(1500, 1200, 1), object_type="ground")


class Config:
    TIME_STEP: float
    NODE_DISTANCE: float
    AIR: Material
    GLASS: Material
    WOOD: Material
    ENVIRONMENT: UniformTemperatureObject
    GROUND: UniformTemperatureObject

    _shared_state = dict()

    def __init__(self):
        self.__dict__ = self._shared_state

    def __getitem__(self, key):
        return self._shared_state[key]

    def __setitem__(self, key, value):
        self._shared_state[key] = value

Config().TIME_STEP = TIME_STEP
Config().NODE_DISTANCE = NODE_DISTANCE
Config().AIR = AIR
Config().GLASS = GLASS
Config().WOOD = WOOD
Config().ENVIRONMENT = ENVIRONMENT
Config().GROUND = GROUND


# Path: visualization.py
from vpython import *
from colorsys import hsv_to_rgb

#utility functions 
def tuple_to_vector(tup):
    return vector(tup[0], tup[1], tup[2])

class Object3D:
    local_position: vector
    global_position: vector
    size: vector
    parent: "Object3D"
    children: list["Object3D"]
    shape: box

    object_label: label

    def __init__(self, local_position: vector, dimensions: vector, parent: "Object3D" = None):
        self.local_position = local_position
        self.size = dimensions
        self.children = []
        self.shape = None
        self.set_parent(parent)
    
    def get_label(self) -> str | None:
        return None
    
    def get_temperature(self) -> float | None:
        return None
    
    def on_temperature_change(self):
        if self.shape:
            new_temperature = self.get_temperature()
            if new_temperature is not None:
                self.shape.color = self.map_temperature_to_color(new_temperature)
            new_label = self.get_label()
            if new_label is not None:
                self.object_label.text = new_label
        
    def update_position(self):
        if self.parent:
            self.global_position = self.parent.global_position + self.local_position
        else:
            self.global_position = self.local_position
        if self.shape:
            self.shape.pos = self.global_position
        self.update_children()
         
    def update_children(self):
        for child in self.children:
            child.update_position()   
            
    def set_parent(self, parent):
        self.parent = parent
        if parent != None and self not in parent.children and parent != self:
            parent.children.append(self) 
        self.update_position()     
    
    def set_position(self, position : vector):
        self.local_position = position
        self.update_position()
         
            
    def make_box(self, color=vector(255, 255, 255), temperature=None, opacity=0.8):
        l = self.get_label()
        if l is not None:
            self.object_label = label(pos=self.global_position, text=l)

        if(temperature != None):
            color = self.map_temperature_to_color(temperature)
        self.shape = box(pos=self.global_position, size=self.size, opacity=opacity, color=color)
        
    def map_temperature_to_color(self, temperature_kelvin):
        temperature = temperature_kelvin - 273.15 # convert to celsius
        normalized_temperature = 0.6 - 0.6*(temperature + 20)/70 # temp scale from -10 to 40, accepted 0, 40
        h = normalized_temperature #(1 - normalized_temperature)  # H 
        s = 0.8  # Saturation
        v = 1.0  # Value
        
        color_rgb = hsv_to_rgb(h, s, v)
        return vector(color_rgb[0], color_rgb[1], color_rgb[2])
   

# Path: __init__.py


# Path: heating_systems.py
from ..generic import *


class Radiator(HeatingSystem):
    def __init__(self, power, temperature):
        HeatingSystem.__init__(self, 'Radiator', power, temperature)


# Path: house.py
from .room import *
from .layered_objects import MultiLayerObject
from ..generic import Material, UniformTemperatureObject, Direction, Axis
from ..heat_flow import HeatFlow
from ..model_parameters import Config

from itertools import product as cartesian_product


def reverse_direction(direction: Direction):
    # return (direction+2) if direction%2==direction else (direction-2)
    return Direction(direction.axis, not direction.positive)

class House(Object3D):
    rooms: list[Room]
    room_connections: dict[Room, list[tuple[Room, Direction]]] = dict()

    def __init__(self, rooms: list[Room], interfaces, wall_layers, roof_layers, floor_layers,
                 local_position = vector(0, 0, 0)):
        Object3D.__init__(self, dimensions=vector(0, 0, 0), local_position=local_position)
        self.rooms = rooms

        visited_interfaces = set()
        for room in self.rooms:
            room.set_parent(self) # visually group rooms together
            
            self.room_connections[room] = []
            for interface in interfaces:
                interface_rooms, direction = interface
                if room in interface_rooms and tuple(interface_rooms) not in visited_interfaces:
                    if room is interface_rooms[0]:
                        self.room_connections[room].append((interface_rooms[1], direction))
                    else:
                        self.room_connections[room].append((interface_rooms[0], reverse_direction(direction)))
                    visited_interfaces.add(tuple(interface_rooms))
                    

        for room in self.rooms:
            self.generate_walls(room, wall_layers)
            #room.walls = [MultiLayerObject(room.dimensions[2], room.dimensions[i%2], 20, wall_layers, border=([room, ENVIRONMENT] if i<2 else [ENVIRONMENT, room])) for i in range(4)]
            room.roof = MultiLayerObject(Axis.X, Axis.Z, room.dimensions[Axis.X], room.dimensions[Axis.Z], 20, roof_layers, border=[room, Config().ENVIRONMENT])
            room.floor = MultiLayerObject(Axis.X, Axis.Z, room.dimensions[Axis.X], room.dimensions[Axis.Z], 20, floor_layers, border=[Config().GROUND, room])
        
        for room in self.rooms:
            for room2, direction in self.room_connections[room]:
                room.walls[direction].border = [room, room2]
                room2.walls[reverse_direction(direction)] = room.walls[direction]

    
    def print_rooms_temperatures(self):
        print("ROOMS:")
        for room in self.rooms:
            print(room.temperature - 273.15, "°C")
        print("ENVIRONMENT:", Config().ENVIRONMENT.temperature - 273.15, "°C")
        print("GROUND:", Config().GROUND.temperature - 273.15, "°C")
    
    def update_temperature(self):
        walls = [wall for room in self.rooms for wall in room.walls.values()]
        HeatFlow.update_temperature(walls
                                    + [room.roof for room in self.rooms]
                                    + [room.floor for room in self.rooms]
                                    + [opening for wall in walls for opening in wall.openings])
    
    def update_visuals(self):
        for room in self.rooms:
            room.on_temperature_change()
    
  
    def generate_walls(self, room: Room, wall_layers):
        for direction in [Direction(axis, positive) for axis, positive in cartesian_product([Axis.X, Axis.Z], [True, False])]:
            height = room.dimensions[Axis.Y]
            wall_axis = Axis.X if direction.axis == Axis.Z else Axis.Z
            width = room.dimensions[wall_axis]
            x, z = 0, 0
            if direction.axis == Axis.X:
                x = room.dimensions[direction.axis]/2 if direction.positive else -room.dimensions[direction.axis]/2
            else:
                z = room.dimensions[direction.axis]/2 if direction.positive else -room.dimensions[direction.axis]/2
            wall = MultiLayerObject(Axis.Y, wall_axis, height, width, 20, wall_layers, border=([room, Config().ENVIRONMENT] if direction.positive else [Config().ENVIRONMENT, room]), openings=list(), 
                                               local_position=vector(x, 0, z), parent=room)
            room.walls[direction] = wall
            

    def add_openings(self, wall: MultiLayerObject, i: int):    
        if(len(wall.openings) == 0):
            #return
            wall.openings.append(MultiLayerObject(0.5, 0.5, 20, [(0.1, Material(1225, 1005, 0.024))], border=[wall, Config().ENVIRONMENT], local_position=vector(0, 0, 0), parent=None))
            wall.openings.append(MultiLayerObject(0.5, 0.5, 20, [(0.1, Material(1225, 1005, 0.024))], border=[wall, Config().ENVIRONMENT], local_position=vector(0, 0, 0), parent=None))
        num_openings = len(wall.openings)
        distance_between_openings = wall.axis2_length/(num_openings+1)
        initial_position = -wall.axis2_length/2 + distance_between_openings
        for j in range(num_openings):
            if(wall.openings[j].parent is not None):
                continue
            
            offset = initial_position + j*distance_between_openings
            x = 0 if i%2==1 else offset
            z = 0 if i%2==0 else offset
            wall.openings[j].local_position = vector(x, 0, z)
            wall.openings[j].set_parent(wall)
            wall.openings[j].make_box()
            if(i%2==1):
                wall.openings[j].shape.rotate(angle=pi/2, axis=vector(0, 1, 0))
        



# Path: layered_objects.py
from ..generic import UniformTemperatureObject, Material, Axis
from ..visualization import Object3D
from ..model_parameters import Config

from vpython import vector

class ObjectLayer:
    thickness: float
    material: "Material"
    parent_object: "MultiLayerObject"
    nodes: list["UniformTemperatureObject"]

    def __init__(self, init_temperature_celsius: float, thickness: float, material: "Material", parent_object: "MultiLayerObject"):
        self.thickness = thickness
        self.material = material
        self.parent_object = parent_object

        self.nodes = [UniformTemperatureObject(init_temperature_celsius, material, self.parent_object.area*Config().NODE_DISTANCE, object_type="node") for _ in range(int(thickness // Config().NODE_DISTANCE))]


class MultiLayerObject(Object3D):
    layers: list[ObjectLayer]
    axis1: Axis
    axis2: Axis
    axis1_length: float
    axis2_length: float
    border: list["UniformTemperatureObject"]

    def __init__(self, axis1, axis2, axis1_length, axis2_length, init_temperature_celsius: float, layers: list[list[float, "Material"]], border: list["UniformTemperatureObject"], openings: list["MultiLayerObject"] = list(), #dict[tuple[float, float], "MultiLayerObject"] = dict(),
                local_position = vector(0, 0, 0), parent: "Object3D" = None):
        self.axis1 = axis1
        self.axis2 = axis2
        self.axis1_length = axis1_length
        self.axis2_length = axis2_length
        self.openings = openings
        self.init_temperature_celsius = init_temperature_celsius
        self.layers: list[ObjectLayer] = [ObjectLayer(init_temperature_celsius, thickness, material, self) for thickness, material in layers]
        self.border = border
        super().__init__(dimensions=vector(*self.dimensions), local_position=local_position, parent=parent)

        for opening in openings:
            opening.parent = self
        
    @property   
    def thickness(self):
        return sum(layer.thickness for layer in self.layers)
    
    @property
    def area(self):
        return self.axis1_length * self.axis2_length - sum(opening.area for opening in self.openings)

    @property
    def nodes(self):
        return [node for layer in self.layers for node in layer.nodes]

    @property
    def dimensions(self):
        axis_to_length = {self.axis1: self.axis1_length, self.axis2: self.axis2_length}
        return [axis_to_length.get(axis, self.thickness) for axis in Axis]


    def add_window(self, position: tuple[float], size: tuple[float, float]):
        window = MultiLayerObject(self.axis1, 
                                  self.axis2, 
                                  *size,
                                  self.init_temperature_celsius,
                                  [[0.07, Config().GLASS]], 
                                  border=self.border,
                                  local_position=vector(*position),
                                  parent=self)
                                  
        self.openings.append(window) 
        
        self.layers = [ObjectLayer(self.init_temperature_celsius, layer.thickness, layer.material, self) for layer in self.layers]

    def add_door(self, position: tuple[float], size: tuple[float, float]):
        door = MultiLayerObject(self.axis1, 
                                  self.axis2, 
                                  *size,
                                  self.init_temperature_celsius,
                                  [[0.07, Config().WOOD]], 
                                  border=self.border,
                                  local_position=vector(*position),
                                  parent=self)
                                  
        self.openings.append(door) 
        
        self.layers = [ObjectLayer(self.init_temperature_celsius, layer.thickness, layer.material, self) for layer in self.layers]
    
    def visualize_openings(self):
        for opening in self.openings:
            opening.make_box(color=vector(0, 0, 0))

# Path: room.py
from .heating_systems import *
from .layered_objects import MultiLayerObject
from ..generic import *
from ..model_parameters import Config



class Room(UniformTemperatureObject, Object3D):
    id: int
    dimensions: tuple[float, float, float]
    walls: dict[Direction, MultiLayerObject]
    roof: MultiLayerObject
    floor: MultiLayerObject

    def __init__(self, id, dimensions, init_temperature_celsius,
                 local_position = vector(0, 0, 0), parent: "Object3D" = None):
        super().__init__(init_temperature_celsius, Config().AIR, prod(dimensions), object_type="room")

        self.dimensions = dimensions
        self.walls = dict()
        self.id = id
        self.roof = None
        self.floor = None
        Object3D.__init__(self, dimensions=tuple_to_vector(dimensions), local_position=local_position, parent=parent)

    def add_windows(self, direction: Direction, n: int):
        wall = self.walls[direction]
        wall_axis = Axis.X if direction.axis == Axis.Z else Axis.Z
        for width_pos in [wall.dimensions[wall_axis]*(i/(n+1) - 1/2) for i in range(1, n+1)]:
            position = [0, wall.dimensions[Axis.Y]*(2/3 - 1/2), 0]
            position[wall_axis] = width_pos
            wall.add_window(position=position, size=(0.8, 0.8))
    
    def add_door(self, direction: Direction):
        wall = self.walls[direction]
        wall_axis = Axis.X if direction.axis == Axis.Z else Axis.Z
        size = [2, 1]
        position = [0, (1/2)*size[0]-(1/2)*wall.dimensions[Axis.Y], 0]

        wall.add_door(position=position, size=size)
    
    def visualize_openings(self):
        for wall in self.walls.values():
            wall.visualize_openings()

    def get_label(self):
        return f"Room {self.id}: {self.temperature - 273.15:.2f} C"

    def get_temperature(self):
        return self.temperature

# Path: __init__.py


